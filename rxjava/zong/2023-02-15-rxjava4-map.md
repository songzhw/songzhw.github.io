# map操作

## 最简单的map操作

`map()`很简单, 就不讲了. 

另注: 对于熟悉RxJS的同学来说, RxJS中有mapTo(t), pluck(keyName), 但请注意, RxJava中没有这2个操作符. 


## 转为集合

这一类操作符, 是把Observable<T>中发出来那些数据, 全装到一个集合(如list, map, ...)里去. 

### 转到list里

可以直接用系统的list, 也可能自己提供一个List实例, 甚至是sortedList

```kotlin
       Observable.just(1, 2, 3, 4)
            .toList() // Receives first emission at 1 sec
            .subscribe { l -> println("Received: $l") }//=> received: [1,2,3,4]

        Observable.just(1, 2, 3, 4)
            .toList { CopyOnWriteArrayList<Int>() }
            .subscribe { l -> println("Received: ${l.javaClass}") }
        //=> Received: class java.util.concurrent.CopyOnWriteArrayList

        Observable.just("Beta", "Alpha", "Delta", "Gamma", "Zeta", "Eta")
            .toSortedList()
            .subscribe { l -> println("Received: $l") }
        //=> Received: [Alpha, Beta, Delta, Eta, Gamma, Zeta]

```


### 转到map里去

这里注意, toMultipleMap并不是转到多个map中去, 而是指有重复元素时不要覆盖, 而是放到list类型的value里去. 来看例子: 

```kotlin
        Observable.just("Alpha", "Ago","Beta", "Gamma", "Delta", "Epsilon", "Zeta")
            .toMap { s -> s[0] }
            .subscribe { m -> println("Received: $m") }
        //=> Received: {A=Ago, B=Beta, D=Delta, E=Epsilon, G=Gamma, Z=Zeta}
        // 注意到, Alpha已经被Ago给覆盖掉了

        Observable.just("Alpha", "Ago","Beta", "Gamma", "Delta", "Epsilon", "Zeta")
            .toMultimap { s -> s[0] }
            .subscribe { m -> println("Received: $m") }
        //=> Received: {A=[Alpha, Ago], B=[Beta], D=[Delta], E=[Epsilon], G=[Gamma], Z=[Zeta]}
        // 即有重复的不覆盖, 而是放到一个数组里去.

        Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon", "Zeta")
            .toMap({ s -> s[0] }, { s -> s.length })
            .subscribe { m -> println("Received: $m") }
        //=> Received: {A=5, B=4, D=5, E=7, G=5, Z=4}
        // toMap提供第二个参数, 用来提供不同的value值
```


### 自定义容器

若上面的list, map都不满足我们的需求, 如我们想放到Set里, 或是想放到BlockingQueue里, 这时我们就得利用`collect`操作符, 来提供我们自己自定义的容器, 然后把流的数据都收集到这个自定义窗口里去

```kotlin
        Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon", "Zeta")
            .collect({ HashSet<String>() }, { s, v -> s.add(v) })
            .subscribe { s -> println("Received: ${s.javaClass} : $s") }
        //=> Received: class java.util.HashSet : [Gamma, Zeta, Delta, Alpha, Epsilon, Beta]
        // 若不是map, list的容器来收集数据, 那就要用collect, 第一参提供一个新容器, 第二参是容器如何处理到达的数据

```

p.s. 下面我们马上在分组这一小节就要用到这个collect.




## 分组

对于熟悉RxJS的同学来说, RxJS中有groupBy与partition这两个分组操作符. 而RxJava中只有groupBy.


这里值得注意的是, gorupBy自己返回的并不一个Observable<List<T>>, 反而是另一个Observable, 所以我们要自己用`collect()`来收集数据, 达到我们想要Observable<List<T>>的效果

```kotlin
internal class DateModel(var date: Int, var value: Int) :
    Comparable<DateModel?> {
    override fun compareTo(other: DateModel?): Int {
        if (other == null) return -1
        return value.compareTo(other.value)
    }

    override fun toString() = "DM($date, $value)"

}

val dateList: List<DateModel> = arrayListOf(
    DateModel(18, 1), DateModel(18, 2), DateModel(18, 3), DateModel(19, 1),
    DateModel(19, 2), DateModel(19, 3), DateModel(19, 4)
)
```

对这一组数组我们来分组: 

```kotlin
    val src: Observable<PriorityQueue<DateModel>> = Observable.fromIterable(dateList)
    .groupBy { dateModel -> dateModel.date }
    .flatMap { groups -> groups.collect( // collect就是把上游的数据收集起来, 放到一个容器里去
        { PriorityQueue<DateModel>() }, /* Supplier, 提供一个容器来收数据 */
        { queue: PriorityQueue<DateModel>, datum: DateModel -> /* 这里的参数是上面的容器与流中的数据*/
            queue.add(datum)
        }).toObservable() }

    src.prints(disposables, "1C")
    //=> szw(1c) [DM(18,1), DM(18,2), DM(18,3)]
    //=> szw(1c) [DM(19,1), DM(19,2), DM(19,3), DM(19,4)]
```

这里我们用`collect`提供第一参, 即一个PriorityQueue来收集发出来的数据; 第二参, 即一个lambda来收集数据 `queue.add(datum)`


## 累积操作

对于Python比较熟悉的同学, 肯定很熟悉`reduce`这个函数了. RxJava中也有类似的`reduce`与`scan`, 那这二者有什么区别? 

: 总得来说, 就是

* reduce只会返回一个汇总结果给下游
* 而scan则是每一个数据都下发, 是的, 即使是第一个数据


```kotlin
Observable.just(2, 3,5,8)
    .reduce { accumulated, current -> accumulated + current}
    .prints(disposables, "2A")
//=> 注意到, current=2时, 因为还没有accumulated, 所以不走reduce. 而2也会做为第二个数据的accumulated
//=> szw(2A) 18
```


```kotlin
    Observable.just(2, 3,5,8)
        .scan { accumulated, current -> accumulated + current }
        .prints(disposables, "2B")
    //=> szw(2B) 2
    //=> szw(2B) 5
    //=> szw(2B) 10
    //=> szw(2B) 18
```


另外, reduce与scan都可以有seed(初始值), 或是seedSupplier(一个提供初始值的函数)

```kotlin
Observable.just(2, 3, 5, 8)
    .reduce(100)  { accumulated, current -> accumulated + current }
    .prints(disposables, "2C") //=> 118

Observable.just(2, 3, 5, 8)
    .reduceWith(
        { 200 }, //一个函数用来提供seed
        { accumulated, current -> accumulated + current }
    )
    .prints(disposables, "2D") //=> 218
   
```