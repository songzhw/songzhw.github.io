## I. Introduction
Fragment has been made since 2011 for the support of tablet on Android 3.0+. The original intention is that it can help us to write once, but two different UI for phones and tablets. 

[Fragment's usage on different devices](https://i.stack.imgur.com/FtzKs.png)

But this seems only works for the list. More complex UI is hard to fulfill this goal. However, smart developers found out that Fragment actually could do a single part of UI View, so we could compose different Fragment to one screen, and, oh yearh, we could reuse our View code. Wasn't it wonderful?!

I was one of these excited developers. But after several years of using Fragment, I have to say, Fragment is one of the worst product in the Android world. Wait a minute, I am not here to declare a war, please allow me to explain more details.

## II. Transaction
 
### 2.1 commit() and state loss

One of the most common crash I can see is `java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState`. 

This exception is Android trying to tell you that if you update the Fragment after the app is being backgrounded or killed, then your update might be recorded in teh onSaveInstanceState(). So next time you bring back the app, this kind of update would be lost. 

I get it, and it's good. But sometimes we do not know when is the time to call `fragment.commit()`, especially your `fragment.commit()` happens in one async callback. It's totally possible that I just send a HTTPS reqeust to fetch something, and then the user backgrounds our app. When the response arrives, we want to do something and call `newFragment.commit()`.
One possible solution is to use `fragment.commitAllowingStateLoss()`.  `commitAllowingStateLoss()` is not a good idea in generally, you can only use it when you are really sure this kind of update is okay to be lost. Remeber to pay attention to this `commitAllowingStateLoss()` method when you are reviewing your colleage's PR.

### 2.2 no commitAllowingStateLoss()?
`AlertDialog` is now not encouraged to use. Instead, Google suggests you to use `DialogFragment`. That's fine. But if you want to commit a dialog in a async callback, and you have put your app in the background, you will get the previous error agagin.

Just unfortunately for us, `DialogFragment` does not have the `commitAllowingStateLoss()` method. Yeah, I am so frustrated by this reality when I had this error, and I still have no good solution for this. In my opinion, if the app is killed accidently, and is brought back to foreground, it really is not a big deal that if the dialog is not showing. But a mandatory crash seems a overkill.

### 2.3 dialogFragment.dismiss()
Now I have a business scenario: I have to dismiss a popped up dialog first, then go fetch something from the backend. If I can get the successful response, then I can go to the next Activity. Here is the code

```java
// ResetPasswordDialog
this.dismiss();
anotherDialogFragment.sow(fragmentManager, tag)
httpEngine.fetch(){ resp ->
      mActivity.startActivity(someIntent)
}
```

You may have guessed what could happen. My app crashes: `java.lang.NullPointException : mActivity is null`.
Yes, after `this.dismiss`, the `mActivity` is now detached, and the value is null.