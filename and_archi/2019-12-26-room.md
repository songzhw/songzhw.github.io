Room has been out for serveral years, I haven't used it until this year. And I do learn a lot this time, and would like to take a note of it.

Before I dive in, I would say, the version of Room I'm using is :

```
def room_version = "2.2.2"

    // ROOM
    implementation "androidx.room:room-runtime:$room_version"
    kapt "androidx.room:room-compiler:$room_version"
    implementation "androidx.room:room-ktx:$room_version" // ktx + Coroutine
```

By the way, you can check [here](https://developer.android.com/jetpack/androidx/releases/room) to see the release log of Room.

## Relation
The first thing I would state is the relation in ROOM. As we all know, if you have multiple tables and there might be 1:1, 1:Many, Many:Many relation among these tables.

I would like to explain how to build a many to many relation using Room, as this is the hardest relation for us.  Say I have a recipe database, which has two tables: "ingredient" and "recipe". The relation between ingredient and recipe, of course, are many to many. Here is how we retrieve data from Database

1). We define the entities first

```kotlin

@Entity
data class Ingredient(
    val name: String,
    val isVegi: Int,
    @PrimaryKey(autoGenerate = true) var ingredientId: Int = 0
) 

@Entity
data class Cuisine(
    val name: String,
    @PrimaryKey(autoGenerate = true) var cuisineId: Int = 0
)

```

Note that we have to have one, and only one, field annoated with @PrimaryKey in every Entity class.
p.s. You could add @ForeignKey as well. 

2). As we know, many to many relation also requires an extra table to save the relations. That's why we still need one more table.

```kotlin
@Entity
data class IngredientCuisine(
    @ForeignKey(
        entity = Ingredient::class,
        parentColumns = ["ingredientId"],
        childColumns = ["ingredientId"]
    )
    val ingredientId: Int,

    @ForeignKey(
        entity = Cuisine::class,
        parentColumns = ["cuisineId"],
        childColumns = ["cuisineId"]
    )
    val cuisineId: Int,

    @PrimaryKey(autoGenerate = true)
    var icID: Int = 0
)
```

3). Now if we want to know what ingredients are in one specific cuisine, then we need to have a new POJO class to get the data from database. But note that this new POJO class is not an Entity class. Entity is normally a table, but this new POJO class is only the result of query.

```kotlin
data class CuisineWithIngredients(
    @Embedded val cuisine: Cuisine,
    @Relation(
        parentColumn = "cuisineId",
        entity = Ingredient::class,
        entityColumn = "ingredientId",
        associateBy = Junction(IngredientCuisine::class)
    )
    val ingredients: List<Ingredient>
)
```
Note that we have @Embadded cuisines, and also a @Relation annotation to state the relation between two tables. The `IngredientCuisine` class of course is the bridge between Ingredient and Cuisine.

Note that this @Relation(associateBy) is since Room 2.2! 

4). Now we finally could go to retrieve the Cuisine data from database.

```kotlin
@Dao
interface RecipeDao {
    @Query("select * from Cuisine")
    suspend fun cuisinesWithIngredients(): List<CuisineWithIngredients>
    ...
}

@Database(
    entities = [Ingredient::class, Cuisine::class, IngredientCuisine::class],
    version = 1
)
abstract class RecipeDatabase : RoomDatabase() {
    abstract fun dao(): RecipeDao
}
```

Note that the `@Query("select * from Cuisine")` is only query from `Cuisine` table, but what you got is actually a list of `CuisineWithIngredients`.

## pre-packaged database


## search text


## unit test


## ref
[What's new in ROOM(Android Dev Summit '19)] (https://www.youtube.com/watch?v=_aJsh6P00c0) is a great video that deserve your 16 minutes to watch. It presents many useful new feature, such as pre-packaged db and realtion. I strongly suggest you to take a look.