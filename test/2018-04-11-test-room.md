Room is a persistence library provided by Google. It provides an abstraction layer over SQLite to allow fluent database access. In short, it's like the Hiberate in the server development. This post is most focusing on the testing on Room.

### I. Test Room
Android released [one page to tell us how to test our database](https://developer.android.com/training/data-storage/room/testing-db.html). What it did is quite easy, and it just saving and reading from memory instead of a real database instead.

Here is one test code that is recommended by Android:
```java
@RunWith(AndroidJUnit4.class)
public class SimpleEntityReadWriteTest {
    private UserDao mUserDao;
    private TestDatabase mDb;

    @Before
    public void createDb() {
        Context context = InstrumentationRegistry.getTargetContext();
        mDb = Room.inMemoryDatabaseBuilder(context, TestDatabase.class).build();
        mUserDao = mDb.getUserDao();
    }

    @After
    public void closeDb() throws IOException {
        mDb.close();
    }

    @Test
    public void writeUserAndReadInList() throws Exception {
        User user = TestUtil.createUser(3);
        user.setName("george");
        mUserDao.insert(user);
        List<User> byName = mUserDao.findUsersByName("george");
        assertThat(byName.get(0), equalTo(user));
    }
}
```

### II. Why this is not enough?
But I had to say, this is quite limited. First of all, to use "AndroidJUnit4", you will be asked to provide a device or emulator to run this test. Second, since it involves passing test to device/emulator, it takes more time than just pure JUnit test. 

Okay, I had to admit that this is actually the down side of AndroidJUnit test. And that's also why I recommended Robolectric test. Robolectric requires no device or emulator, and it's pure JUnit test, which makes it very fast. If you have to run the test every day, you will know how much time you saved every single day.

So I tried to replace it with Robolectric test. However, things are not going as well as I expected.  I encoutered a couple of tricky problems. That's  actually this blog for, to tell you how to use Robolectric to test Room, and show you how to avoid the same mistakes I made.

### III.  Error01 : run DB on the main thread
Now I had a database to stroe information about users, and I wrote a test to make sure it works. The following code is the test I made. 
```java


@RunWith(RobolectricTestRunner.class)
@Config(constants = BuildConfig.class, sdk = 21)
public class AppDatabaseTest {
    private AppDatabase db;
    private UserDao dao;

    @Before
    public void setUp() {
        db = Room.inMemoryDatabaseBuilder(RuntimeEnvironment.application, AppDatabase.class).build();
        dao = db.userDao();
    }

    @After
    public void cleanUp(){
        db.close();
    }

    @Test
    public void readJordon_userNotFound() {
        System.out.println("szw1 Thread = "+Thread.currentThread().getName());
        User user  = dao.findByName("jorden");
        assertNull(user);
    }
    
}
```

After I run it, I got a error :
``` java
java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.

    at android.arch.persistence.room.RoomDatabase.assertNotMainThread(RoomDatabase.java:164)
    at android.arch.persistence.room.RoomDatabase.query(RoomDatabase.java:192)
    at ca.six.archdemo.intro.room.basic.UserDao_Impl.findByName(UserDao_Impl.java:212)
    at ca.six.archdemo.intro.room.basic.AppDatabaseTest.readJordon_userNotFound(AppDatabaseTest.java:41)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
```

That's true. Robolectric is a tool to test UI, so every Robolectric test case is actually running on the main thrad.  Thus,  I decided to wrap a thread to run the test.

### IV.  Error02: add a thread
```java
    @Test
    public void readJordon_userNotFound() {
        Thread thread = new Thread( () -> {
            System.out.println("szw1 Thread = " + Thread.currentThread().getName());
            User user = dao.findByName("jorden");
            assertNull(user);
        });
        thread.start();
    }
```
This time, it works!

![](./_image/2018-04-09-11-22-50.jpg)


But really? Let's do some modification to the test. Now we just change the  `assertNulll(user)` to `assertNotNul(user))`. These two are obsolutely opposite. So the test should faild right now. Am I right?

```java
   @Test
    public void readJordon_userNotFound() throws InterruptedException {
        Thread thread = new Thread( () -> {
            System.out.println("szw1 Thread = " + Thread.currentThread().getName());
            User user = dao.findByName("jorden");
            assertNull(user);
        });
        thread.start();
    }
```

Weird, now the test also passed.  Now I realised, actually the test code in the thread never completed, so no matter what kind of assertation you add, it will always succeed. 

### V. wait the thread to finish





